// Generated by CoffeeScript 1.12.3
var fs;

fs = require('fs');

module.exports = {
  chmod: function(ssh, path, mode, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.chmod(path, mode, function(err) {
        return callback(err);
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.chmod(path, mode, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  chown: function(ssh, path, uid, gid, callback) {
    var open, ref, ref1;
    if (!((uid != null) || (gid != null))) {
      return callback(new Error('Either option "uid" or "gid" is required'));
    }
    if (!ssh) {
      return fs.chown(path, uid, gid, function(err) {
        return callback(err);
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.chown(path, uid, gid, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  createReadStream: function(ssh, source, options, callback) {
    var open, ref, ref1;
    if (arguments.length === 3) {
      callback = options;
      options = {};
    }
    if (!ssh) {
      return callback(null, fs.createReadStream(source, options));
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var s;
        if (err) {
          return callback(err);
        }
        s = sftp.createReadStream(source, options);
        s.emit = (function(emit) {
          return function(key, val) {
            if (key === 'error' && (val != null ? val.message : void 0) === 'Failure') {
              val = new Error("EISDIR: illegal operation on a directory, read");
              val.errno = 28;
              val.code = 'EISDIR';
              return emit.call(this, 'error', val);
            }
            if (key === 'error' && val.message === 'No such file') {
              val = new Error("ENOENT: no such file or directory, open '" + source + "'");
              val.errno = 34;
              val.code = 'ENOENT';
              val.path = source;
              return emit.call(this, 'error', val);
            }
            return emit.apply(this, arguments);
          };
        })(s.emit);
        s.on('close', function() {
          return sftp.end();
        });
        return callback(null, s);
      });
    }
  },
  createWriteStream: function(ssh, path, options, callback) {
    var open, ref, ref1;
    if (arguments.length === 3) {
      callback = options;
      options = {};
    }
    if (!ssh) {
      return callback(null, fs.createWriteStream(path, options));
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var ws;
        if (err) {
          return callback(err);
        }
        ws = sftp.createWriteStream(path, options);
        ws.on('close', function() {
          return sftp.end();
        });
        return callback(null, ws);
      });
    }
  },
  exists: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.exists(path, function(exists) {
        return callback(null, exists);
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.stat(path, function(err, attr) {
          sftp.end();
          return callback(null, err ? false : true);
        });
      });
    }
  },
  futimes: function(ssh, path, atime, mtime, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.open(path, 'r', function(err, fd) {
        if (err) {
          return callback(err);
        }
        return fs.futimes(fd, atime, mtime, function(err) {
          if (err) {
            return callback(err);
          }
          return fs.close(fd, callback);
        });
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var end;
        end = function(err) {
          sftp.end();
          return callback(err);
        };
        if (err) {
          return end(err);
        }
        return sftp.open(path, 'r', function(err, fd) {
          if (err) {
            return end(err);
          }
          return sftp.futimes(fd, atime, mtime, function(err) {
            if (err) {
              return end(err);
            }
            return sftp.close(fd, function(err) {
              return end(err);
            });
          });
        });
      });
    }
  },
  lstat: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.lstat(path, function(err, stat) {
        return callback(err, stat);
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.lstat(path, function(err, attr) {
          sftp.end();
          if (err && (err.type === 'NO_SUCH_FILE' || err.code === 2)) {
            err.code = 'ENOENT';
            return callback(err);
          }
          return callback(err, attr);
        });
      });
    }
  },
  mkdir: function(ssh, path, options, callback) {
    var open, ref, ref1;
    if (arguments.length === 3) {
      callback = options;
      options = 0x1ff;
    }
    if (typeof options !== 'object') {
      options = {
        mode: options
      };
    }
    if (options.permissions) {
      process.stderr.write('Deprecated, use mode instead of permissions');
      options.mode = options.permissions;
    }
    if (typeof options.mode === 'string') {
      options.mode = parseInt(options.mode, 8);
    }
    if (!ssh) {
      return fs.mkdir(path, options.mode, function(err) {
        if (err) {
          return callback(err);
        }
        if (!(options.uid || options.gid)) {
          return callback();
        }
        return fs.chown(path, options.uid, options.gid, callback);
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var chown, finish, mkdir;
        if (err) {
          return callback(err);
        }
        mkdir = function() {
          return sftp.mkdir(path, options, function(err, attr) {
            if ((err != null ? err.message : void 0) === 'Failure') {
              err = new Error("EEXIST: file already exists, mkdir '" + path + "'");
              err.errno = 47;
              err.code = 'EEXIST';
              err.path = path;
            }
            if (err) {
              return finish(err);
            }
            return chown();
          });
        };
        chown = function() {
          if (!(options.uid || options.gid)) {
            return finish();
          }
          return sftp.chown(path, options.uid, options.gid, function(err) {
            if (err) {
              return finish(err);
            }
            return finish();
          });
        };
        finish = function(err) {
          sftp.end();
          return callback(err);
        };
        return mkdir();
      });
    }
  },
  readdir: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.readdir(path, callback);
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var not_a_dir;
        if (err) {
          return callback(err);
        }
        not_a_dir = function(err) {
          return sftp.stat(path, function(er, attr) {
            if (!er && !attr.isDirectory()) {
              err = Error("ENOTDIR: not a directory, scandir '" + path + "'");
              err.errno = 27;
              err.code = 'ENOTDIR';
              err.path = path;
            }
            return callback(err);
          });
        };
        return sftp.opendir(path, function(err, handle) {
          if (err) {
            return not_a_dir(err);
          }
          return sftp.readdir(handle, function(err, files) {
            if (err) {
              return callback(err);
            }
            if (!files) {
              files = [];
            }
            return sftp.close(handle, function(err) {
              var file;
              if (err) {
                return callback(err);
              }
              sftp.end();
              files = (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = files.length; i < len; i++) {
                  file = files[i];
                  results.push(file.filename);
                }
                return results;
              })();
              return callback(err, files);
            });
          });
        });
      });
    }
  },
  readFile: function(ssh, path, options, callback) {
    var open, ref, ref1;
    if (arguments.length === 3) {
      callback = options;
      options = {};
    } else {
      if (typeof options === 'string') {
        options = {
          encoding: options
        };
      }
    }
    if (!path) {
      return callback(new Error("Invalid path '" + path + "'"));
    }
    if (!ssh) {
      return fs.readFile(path, options.encoding, function(err, content) {
        return callback(err, content);
      });
    } else {
      if (options.autoClose == null) {
        options.autoClose = false;
      }
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var buffers, finish, s;
        if (err) {
          return callback(err);
        }
        s = sftp.createReadStream(path, options);
        buffers = [];
        s.on('data', function(buffer) {
          if (options.encoding) {
            buffer = Buffer.from(buffer, options.encoding);
          }
          return buffers.push(buffer);
        });
        s.on('error', function(err) {
          if (err.code === 4) {
            err = new Error("EISDIR: illegal operation on a directory, read");
            err.errno = -21;
            err.code = 'EISDIR';
          } else if (err.code === 2) {
            err = new Error("ENOENT: no such file or directory, open '" + path + "'");
            err.errno = 34;
            err.code = 'ENOENT';
            err.path = path;
          }
          return finish(err);
        });
        s.on('end', function() {
          return finish(null, Buffer.concat(buffers));
        });
        return finish = function(err, data) {
          if (!options.autoClose) {
            sftp.end();
          }
          if (!err && options.encoding) {
            data = data.toString();
          }
          return callback(err, data);
        };
      });
    }
  },
  readlink: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.readlink(path, function(err, target) {
        return callback(err, target);
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.readlink(path, function(err, target) {
          sftp.end();
          return callback(err, target);
        });
      });
    }
  },
  rename: function(ssh, source, target, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.rename(source, target, function(err) {
        return callback(err);
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        return sftp.unlink(target, function() {
          return sftp.rename(source, target, function(err) {
            sftp.end();
            return callback(err);
          });
        });
      });
    }
  },
  stat: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.stat(path, function(err, stat) {
        return callback(err, stat);
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.stat(path, function(err, attr) {
          sftp.end();
          if (err && (err.type === 'NO_SUCH_FILE' || err.code === 2)) {
            err.code = 'ENOENT';
            return callback(err);
          }
          return callback(err, attr);
        });
      });
    }
  },
  symlink: function(ssh, srcpath, dstpath, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.symlink(srcpath, dstpath, function(err) {
        return callback(err);
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.symlink(srcpath, dstpath, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  unlink: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.unlink(path, function(err) {
        return callback(err);
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.unlink(path, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  writeFile: function(ssh, source, content, options, callback) {
    var chmod, chown, finish, open, ref, ref1, write;
    if (arguments.length === 4) {
      callback = options;
      options = {};
    } else {
      if (typeof options === 'string') {
        options = {
          encoding: options
        };
      }
    }
    if (!ssh) {
      write = function() {
        var stream;
        if (!(typeof content === 'string' || Buffer.isBuffer(content))) {
          content.on('error', function(err) {
            callback(err);
            return callback = null;
          });
        }
        stream = fs.createWriteStream(source, options);
        if (typeof content === 'string' || Buffer.isBuffer(content)) {
          if (content) {
            stream.write(content);
          }
          stream.end();
        } else {
          content.pipe(stream);
        }
        stream.on('error', function(err) {
          if (callback) {
            return callback(err);
          }
        });
        stream.on('end', function() {
          return s.destroy();
        });
        return stream.on('close', function() {
          return chown();
        });
      };
      chown = function() {
        if (!(options.uid || options.gid)) {
          return chmod();
        }
        return fs.chown(source, options.uid, options.gid, function(err) {
          if (callback(err)) {
            return callback(err);
          }
          return chmod();
        });
      };
      chmod = function() {
        if (!options.mode) {
          return finish();
        }
        return fs.chmod(source, options.mode, function(err) {
          return finish(err);
        });
      };
      finish = function(err) {
        if (callback) {
          return callback(err);
        }
      };
      return write();
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      if (!(typeof content === 'string' || Buffer.isBuffer(content))) {
        content.on('error', function(err) {
          callback(err);
          return callback = null;
        });
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          if (callback) {
            callback(err);
          }
          callback = null;
          return;
        }
        write = function() {
          var ws;
          ws = sftp.createWriteStream(source, options);
          if (typeof content === 'string' || Buffer.isBuffer(content)) {
            if (content) {
              ws.write(content);
            }
            ws.end();
          } else {
            content.pipe(ws);
          }
          ws.on('error', function(err) {
            return finish(err);
          });
          ws.on('end', function() {
            return ws.destroy();
          });
          return ws.on('close', function() {
            return chown();
          });
        };
        chown = function() {
          if (!(options.uid || options.gid)) {
            return chmod();
          }
          return sftp.chown(source, options.uid, options.gid, function(err) {
            if (err) {
              return finish(err);
            }
            return chmod();
          });
        };
        chmod = function() {
          if (!options.mode) {
            return finish();
          }
          return sftp.chmod(source, options.mode, function(err) {
            return finish(err);
          });
        };
        finish = function(err) {
          sftp.end();
          if (callback) {
            callback(err);
          }
          return callback = null;
        };
        return write();
      });
    }
  }
};
