// Generated by CoffeeScript 2.0.2
var fs;

fs = require('fs');

module.exports = {
  // # `ssh2-fs.constants`

  // Export native Node.js access, open, type and mode file constants for comfort.
  constants: fs.constants,
  // # `ssh2-fs.chmod(ssh, path, options, callback)`

  // No arguments other than a possible exception are given to the completion
  // callback. 
  chmod: function(ssh, path, mode, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.chmod(path, mode, function(err) {
        return callback(err);
      });
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.chmod(path, mode, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  // # `ssh2-fs.chown(ssh, path, uid, gid, callback)`

  // No arguments other than a possible exception are given to the completion
  // callback. 
  chown: function(ssh, path, uid, gid, callback) {
    var open, ref, ref1;
    if (!((uid != null) || (gid != null))) {
      return callback(new Error('Either option "uid" or "gid" is required'));
    }
    if (!ssh) {
      return fs.chown(path, uid, gid, function(err) {
        return callback(err);
      });
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.chown(path, uid, gid, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  // # `ssh2-fs.createReadStream(ssh, path, [options], callback)`

  // Pass a new ReadStream object (See Readable Stream) to the completion callback.

  // This differs from the original `fs` API which return the Readable Stream instead
  // of passing it to the completion callback, this is internally due to the ssh2
  // API.

  // Example:   

  // ```coffee
  // fs.createReadStream sshOrNull, 'test.out', (err, stream) ->
  //   stream.pipe fs.createWriteStream 'test.in'
  // ```
  createReadStream: function(ssh, source, options, callback) {
    var open, ref, ref1;
    if (arguments.length === 3) {
      callback = options;
      options = {};
    }
    if (!ssh) {
      return callback(null, fs.createReadStream(source, options));
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var s;
        if (err) {
          return callback(err);
        }
        s = sftp.createReadStream(source, options);
        s.emit = (function(emit) {
          return function(key, val) {
            if (key === 'error' && (val != null ? val.message : void 0) === 'Failure') {
              val = new Error("EISDIR: illegal operation on a directory, read");
              val.errno = 28;
              val.code = 'EISDIR';
              return emit.call(this, 'error', val);
            }
            if (key === 'error' && val.message === 'No such file') {
              val = new Error(`ENOENT: no such file or directory, open '${source}'`);
              val.errno = 34;
              val.code = 'ENOENT';
              val.path = source;
              return emit.call(this, 'error', val);
            }
            return emit.apply(this, arguments);
          };
        })(s.emit);
        s.on('close', function() {
          return sftp.end();
        });
        return callback(null, s);
      });
    }
  },
  // # `createWriteStream(ssh, path, [options], callback)`

  // Pass a new WriteStream object (See Writable Stream) to the completion callback.

  // This differs from the original `fs` API which return the Writable Stream instead
  // of passing it to the completion callback, this is internally due to the ssh2
  // API.

  // Example:   

  // ```coffee
  // misc.file.createWriteStream sshOrNull, 'test.out', (err, stream) ->
  //   fs.createReadStream('test.in').pipe stream
  // ```
  createWriteStream: function(ssh, path, options, callback) {
    var open, ref, ref1;
    if (arguments.length === 3) {
      callback = options;
      options = {};
    }
    if (!ssh) {
      return callback(null, fs.createWriteStream(path, options));
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var ws;
        if (err) {
          return callback(err);
        }
        ws = sftp.createWriteStream(path, options);
        ws.on('close', function() {
          return sftp.end();
        });
        return callback(null, ws);
      });
    }
  },
  // # `ssh2-fs.exists(ssh, path, callback)`

  // `options`         Command options include:   

  // *   `ssh`         SSH connection in case of a remote file path.  
  // *   `path`        Path to test.   
  // *   `callback`    Callback to return the result.   

  // `callback`        Received parameters are:   

  // *   `err`         Error object if any.   
  // *   `exists`      True if the file exists.   

  // Test whether or not the given path exists by checking with the file system.
  // Then call the callback argument with an error and either true or false.
  exists: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.exists(path, function(exists) {
        return callback(null, exists);
      });
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.stat(path, function(err, attr) {
          sftp.end();
          return callback(null, err ? false : true);
        });
      });
    }
  },
  // # `ssh2-fs.futimes(ssh, path, atime, mtime, callback)`

  // Sets the access time and modified time for the resource associated with handle. 
  futimes: function(ssh, path, atime, mtime, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.open(path, 'r', function(err, fd) {
        if (err) {
          return callback(err);
        }
        return fs.futimes(fd, atime, mtime, function(err) {
          if (err) {
            return callback(err);
          }
          return fs.close(fd, callback);
        });
      });
    } else {
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var end;
        end = function(err) {
          sftp.end();
          return callback(err);
        };
        if (err) {
          return end(err);
        }
        return sftp.open(path, 'r', function(err, fd) {
          if (err) {
            return end(err);
          }
          return sftp.futimes(fd, atime, mtime, function(err) {
            if (err) {
              return end(err);
            }
            return sftp.close(fd, function(err) {
              return end(err);
            });
          });
        });
      });
    }
  },
  // # `ssh2-fs.lstat(ssh, path, callback)`

  // The callback gets two arguments (err, stats) where stats is a fs.Stats object.
  // lstat() is identical to stat(), except that if path is a symbolic link, then
  // the link itself is stat-ed, not the file that it refers to. 
  lstat: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.lstat(path, function(err, stat) {
        return callback(err, stat);
      });
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.lstat(path, function(err, attr) {
          sftp.end();
          // see https://github.com/mscdex/ssh2-streams/blob/master/lib/sftp.js#L30
          // ssh2@0.3.x use err.type
          // ssh2@0.4.x use err.code
          if (err && (err.type === 'NO_SUCH_FILE' || err.code === 2)) {
            err.code = 'ENOENT';
            return callback(err);
          }
          return callback(err, attr);
        });
      });
    }
  },
  // # `ssh2-fs.mkdir(ssh, path, [options], callback)`

  // No arguments other than a possible exception are given to the completion
  // callback. mode defaults to 0777.

  // In SSH, options is an [ATTR SSH2 object][attr] and may contains such attributes as
  // 'uid', 'gid' and 'mode'. If option is not an object, it is considered to be the
  // permission mode.

  // For the sake of compatibility, the local mode also accept additionnal options
  // than mode. Additionnal supported options are "uid' and "guid". It differs from
  // the native Node.js API which only accept a permission mode.
  mkdir: function(ssh, path, options, callback) {
    var open, ref, ref1;
    if (arguments.length === 3) {
      callback = options;
      options = 0o0777;
    }
    if (typeof options !== 'object') {
      options = {
        mode: options
      };
    }
    if (options.permissions) {
      process.stderr.write('Deprecated, use mode instead of permissions');
      options.mode = options.permissions;
    }
    if (typeof options.mode === 'string') {
      options.mode = parseInt(options.mode, 8);
    }
    if (!ssh) {
      return fs.mkdir(path, options.mode, function(err) {
        if (err) {
          return callback(err);
        }
        if (!(options.uid || options.gid)) {
          return callback();
        }
        return fs.chown(path, options.uid, options.gid, callback);
      });
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var chown, finish, mkdir;
        if (err) {
          return callback(err);
        }
        mkdir = function() {
          return sftp.mkdir(path, options, function(err, attr) {
            if ((err != null ? err.message : void 0) === 'Failure') {
              err = new Error(`EEXIST: file already exists, mkdir '${path}'`);
              err.errno = 47;
              err.code = 'EEXIST';
              err.path = path;
            }
            if (err) {
              return finish(err);
            }
            return chown();
          });
        };
        chown = function() {
          if (!(options.uid || options.gid)) {
            return finish();
          }
          // chown should be required but mkdir doesnt seem to honor uid & gid attributes
          return sftp.chown(path, options.uid, options.gid, function(err) {
            if (err) {
              return finish(err);
            }
            return finish();
          });
        };
        finish = function(err) {
          sftp.end();
          return callback(err);
        };
        return mkdir();
      });
    }
  },
  // # `ssh2-fs.readdir(path, callback)`

  // Reads the contents of a directory. The callback gets two arguments (err, files)
  // where files is an array of the names of the files in the directory excluding
  // '.' and '..'. 
  readdir: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.readdir(path, callback);
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var not_a_dir;
        if (err) {
          return callback(err);
        }
        not_a_dir = function(err) {
          return sftp.stat(path, function(er, attr) {
            if (!er && !attr.isDirectory()) {
              err = Error(`ENOTDIR: not a directory, scandir '${path}'`);
              err.errno = 27;
              err.code = 'ENOTDIR';
              err.path = path;
            }
            return callback(err);
          });
        };
        return sftp.opendir(path, function(err, handle) {
          if (err) {
            return not_a_dir(err);
          }
          return sftp.readdir(handle, function(err1, files) {
            return sftp.close(handle, function(err2) {
              var file;
              if (err1 || err2) {
                return callback(err1 || err2);
              }
              sftp.end();
              files = (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = files.length; i < len; i++) {
                  file = files[i];
                  results.push(file.filename);
                }
                return results;
              })();
              return callback(err, files);
            });
          });
        });
      });
    }
  },
  // # `ssh2-fs.readFile(ssh, path, [options], callback)` 

  // *   `filename` String   
  // *   `options` Object   
  // *   `options.encoding` String | Null default = null   
  // *   `options.flag` String default = 'r'   
  // *   `callback` Function   

  // Asynchronously reads the entire contents of a file.
  readFile: function(ssh, path, options, callback) {
    var open, ref, ref1;
    if (arguments.length === 3) {
      callback = options;
      options = {};
    } else {
      if (typeof options === 'string') {
        options = {
          encoding: options
        };
      }
    }
    if (!path) {
      return callback(new Error(`Invalid path '${path}'`));
    }
    if (!ssh) {
      return fs.readFile(path, options.encoding, function(err, content) {
        return callback(err, content);
      });
    } else {
      if (options.autoClose == null) {
        options.autoClose = false; // Required after version 0.0.18 (sep 2015)
      }
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        var buffers, finish, s;
        if (err) {
          return callback(err);
        }
        s = sftp.createReadStream(path, options);
        buffers = [];
        s.on('data', function(buffer) {
          if (options.encoding) {
            buffer = Buffer.from(buffer, options.encoding);
          }
          return buffers.push(buffer);
        });
        s.on('error', function(err) {
          if (err.code === 4) {
            err = new Error("EISDIR: illegal operation on a directory, read");
            err.errno = -21;
            err.code = 'EISDIR';
            err.syscall = 'read';
          } else if (err.code === 2) {
            err = new Error(`ENOENT: no such file or directory, open '${path}'`);
            err.errno = 34;
            err.code = 'ENOENT';
            err.path = path;
          }
          return finish(err);
        });
        s.on('end', function() {
          return finish(null, Buffer.concat(buffers));
        });
        return finish = function(err, data) {
          if (!options.autoClose) {
            sftp.end();
          }
          if (!err && options.encoding) {
            data = data.toString();
          }
          return callback(err, data);
        };
      });
    }
  },
  // # `ssh2-fs.readlink(ssh, path, callback)`

  // The callback gets two arguments (err, linkString).
  readlink: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.readlink(path, function(err, target) {
        return callback(err, target);
      });
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.readlink(path, function(err, target) {
          sftp.end();
          return callback(err, target);
        });
      });
    }
  },
  // # `ssh2-fs.rename(sshOrNull, oldPath, newPath, callback)`

  // No arguments other than a possible exception are given to the completion
  // callback. 
  rename: function(ssh, source, target, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.rename(source, target, function(err) {
        return callback(err);
      });
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        return sftp.unlink(target, function() { // Required after version 0.0.18 (sep 2015)
          return sftp.rename(source, target, function(err) {
            sftp.end();
            return callback(err);
          });
        });
      });
    }
  },
  // # `ssh2-fs.stat(ssh, path, callback)`

  // The callback gets two arguments (err, stats) where stats is a fs.Stats object.
  // See the fs.Stats section below for more information.
  stat: function(ssh, path, callback) {
    var open, ref, ref1;
    // Not yet test, no way to know if file is a direct or a link
    if (!ssh) {
      // { dev: 16777218, mode: 16877, nlink: 19, uid: 501, gid: 20,
      // rdev: 0, blksize: 4096, ino: 1736226, size: 646, blocks: 0,
      // atime: Wed Feb 27 2013 23:25:07 GMT+0100 (CET), mtime: Tue Jan 29 2013 23:29:28 GMT+0100 (CET), ctime: Tue Jan 29 2013 23:29:28 GMT+0100 (CET) }
      return fs.stat(path, function(err, stat) {
        return callback(err, stat);
      });
    } else {
      // { size: 646, uid: 501, gid: 20, permissions: 16877, 
      // atime: 1362003965, mtime: 1359498568 }
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.stat(path, function(err, attr) {
          sftp.end();
          // see https://github.com/mscdex/ssh2-streams/blob/master/lib/sftp.js#L30
          // ssh2@0.3.x use err.type
          // ssh2@0.4.x use err.code
          if (err && (err.type === 'NO_SUCH_FILE' || err.code === 2)) {
            err.code = 'ENOENT';
            return callback(err);
          }
          return callback(err, attr);
        });
      });
    }
  },
  // # `ssh2-fs.symlink(ssh, srcpath, linkPath, callback)`

  // No arguments other than a possible exception are given to the completion
  // callback. The type argument can be set to 'dir', 'file', or 'junction'
  // (default is 'file') and is only available on Windows (ignored on other
  // platforms). Note that Windows junction points require the target path to
  // be absolute. When using 'junction', the target argument will automatically
  // be normalized to absolute path. 
  symlink: function(ssh, srcpath, dstpath, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.symlink(srcpath, dstpath, function(err) {
        return callback(err);
      });
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.symlink(srcpath, dstpath, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  // # `ssh2-fs.unlink(ssh, path, callback)`

  // No arguments other than a possible exception are given to the completion
  // callback.
  unlink: function(ssh, path, callback) {
    var open, ref, ref1;
    if (!ssh) {
      return fs.unlink(path, function(err) {
        return callback(err);
      });
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.unlink(path, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  // # `ssh2-fs.writeFile(ssh, path, content, [options], callback)`

  // *   `filename` String   
  // *   `data` String | Buffer | stream reader   
  // *   `options` Object   
  // *   `options.encoding` String | Null default = 'utf8'   
  // *   `options.mode` Number default = 438 (aka 0666 in Octal)   
  // *   `options.flag` String default = 'w'   
  // *   `callback` Function   

  // Asynchronously writes data to a file, replacing the file if it already exists.
  // data can be a string or a buffer.

  // The encoding option is ignored if data is a buffer. It defaults to 'utf8'.
  writeFile: function(ssh, source, content, options, callback) {
    var chmod, chown, finish, open, ref, ref1, write;
    if (arguments.length === 4) {
      callback = options;
      options = {};
    } else {
      if (typeof options === 'string') {
        options = {
          encoding: options
        };
      }
    }
    if (!ssh) {
      write = function() {
        var stream;
        if (!(typeof content === 'string' || Buffer.isBuffer(content))) {
          content.on('error', function(err) {
            callback(err);
            return callback = null;
          });
        }
        stream = fs.createWriteStream(source, options);
        if (typeof content === 'string' || Buffer.isBuffer(content)) {
          if (content) {
            stream.write(content);
          }
          stream.end();
        } else {
          content.pipe(stream);
        }
        stream.on('error', function(err) {
          if (callback) {
            return callback(err);
          }
        });
        stream.on('end', function() {
          return s.destroy();
        });
        return stream.on('close', function() {
          return chown();
        });
      };
      chown = function() {
        if (!((options.uid != null) || (options.gid != null))) {
          return chmod();
        }
        return fs.chown(source, options.uid, options.gid, function(err) {
          if (err) {
            return callback(err);
          }
          return chmod();
        });
      };
      chmod = function() {
        if (!options.mode) {
          return finish();
        }
        return fs.chmod(source, options.mode, function(err) {
          return finish(err);
        });
      };
      finish = function(err) {
        if (callback) {
          return callback(err);
        }
      };
      return write();
    } else {
      // ssh@0.3.x use "_state"
      // ssh@0.4.x use "_sshstream" and "_sock"
      open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
      if (!open) {
        return callback(Error('Closed SSH Connection'));
      }
      if (!(typeof content === 'string' || Buffer.isBuffer(content))) {
        content.on('error', function(err) {
          callback(err);
          return callback = null;
        });
      }
      return ssh.sftp(function(err, sftp) {
        if (err) {
          if (callback) {
            callback(err);
          }
          callback = null;
          return;
        }
        write = function() {
          var ws;
          ws = sftp.createWriteStream(source, options);
          if (typeof content === 'string' || Buffer.isBuffer(content)) {
            if (content) {
              ws.write(content);
            }
            ws.end();
          } else {
            content.pipe(ws);
          }
          ws.on('error', function(err) {
            return finish(err);
          });
          ws.on('end', function() {
            return ws.destroy();
          });
          return ws.on('close', function() {
            return chown();
          });
        };
        chown = function() {
          if (!((options.uid != null) || (options.gid != null))) {
            return chmod();
          }
          return sftp.chown(source, options.uid, options.gid, function(err) {
            if (err) {
              return finish(err);
            }
            return chmod();
          });
        };
        chmod = function() {
          if (!options.mode) {
            return finish();
          }
          return sftp.chmod(source, options.mode, function(err) {
            return finish(err);
          });
        };
        finish = function(err) {
          sftp.end();
          if (callback) {
            callback(err);
          }
          return callback = null;
        };
        return write();
      });
    }
  }
};

// [attr]: https://github.com/mscdex/ssh2-streams/blob/master/SFTPStream.md#attrs
