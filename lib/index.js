// Generated by CoffeeScript 2.5.1
var fs;

fs = require('fs');

module.exports = {
  // # `ssh2-fs.constants`

  // Export native Node.js access, open, type and mode file constants for comfort.
  constants: fs.constants,
  // # `ssh2-fs.chmod(ssh, path, mode)`

  // Asynchronously changes the permissions of a file. No arguments is returned by the function. 
  chmod: function(ssh, path, mode) {
    if (!ssh) {
      return fs.promises.chmod(path, mode);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return reject(err);
          }
          return sftp.chmod(path, mode, function(err) {
            sftp.end();
            if (!err) {
              return resolve();
            } else {
              return reject(err);
            }
          });
        });
      });
    }
  },
  // # `ssh2-fs.chown(ssh, path, uid, gid)`

  // Asynchronously changes owner and group of a file. No arguments is returned by the function. 
  chown: function(ssh, path, uid, gid) {
    if (!((uid != null) || (gid != null))) {
      throw Error('Either option "uid" or "gid" is required');
    }
    if (!ssh) {
      return fs.promises.chown(path, uid, gid);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock": ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return reject(err);
          }
          return sftp.chown(path, uid, gid, function(err) {
            sftp.end();
            if (!err) {
              return resolve();
            } else {
              return reject(err);
            }
          });
        });
      });
    }
  },
  // # `ssh2-fs.createReadStream(ssh, path, [options])`

  // Return a promise with a new [ReadStream
  // object](https://nodejs.org/api/stream.html#stream_class_stream_readable) on
  // completion.

  // In the original `fs` API, `createReadStream` is directly return instead of being
  // available on a promise completion. The reason is due to the nature of
  // the SSH library where we need to create an SFTP instance asynchronously before
  // returning the the writable stream.

  // Example:

  // ```coffee
  // stream = await fs.createReadStream sshOrNull, 'test.out'
  // stream.pipe fs.createWriteStream 'test.in'
  // ```
  createReadStream: function(ssh, source, options = {}) {
    if (!ssh) {
      return fs.createReadStream(source, options);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock": ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          var rs;
          if (err) {
            return reject(err);
          }
          rs = sftp.createReadStream(source, options);
          rs.emit = (function(emit) {
            return function(key, val) {
              if (key === 'error') {
                if (val.code === 4) {
                  val = new Error("EISDIR: illegal operation on a directory, read");
                  val.errno = -21;
                  val.code = 'EISDIR';
                  val.syscall = 'read';
                } else if (val.code === 2) {
                  val = new Error(`ENOENT: no such file or directory, open '${source}'`);
                  val.code = 'ENOENT';
                  val.errno = -2;
                  val.syscall = 'open';
                  val.path = source;
                } else if (val.code === 3) { // Not tested, hard to reproduce without a sudo environment
                  val = new Error(`EACCES: permission denied, open '${source}'`);
                  val.code = 'EACCES';
                  val.errno = -13;
                  val.syscall = 'open';
                  val.path = source;
                }
                return emit.call(this, 'error', val);
              }
              return emit.apply(this, arguments);
            };
          })(rs.emit);
          rs.on('close', function() {
            return sftp.end();
          });
          return resolve(rs);
        });
      });
    }
  },
  // # `createWriteStream(ssh, path, [options])`

  // Return a promise with a new [WriteStream
  // object](https://nodejs.org/api/stream.html#stream_class_stream_writable) on
  // completion.

  // In the original `fs` API, `createWriteStream` is directly return instead of
  // being available on a promise completion. The reason is due to the internal
  // nature where we need to create an SFTP instance asynchronously before returning
  // the the writable stream.

  // Example:

  // ```coffee
  // stream = await fs.createWriteStream sshOrNull, 'test.out'
  // fs.createReadStream('test.in').pipe stream
  // ```
  createWriteStream: function(ssh, path, options = {}) {
    if (!ssh) {
      return fs.createWriteStream(path, options);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock": ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          var ws;
          if (err) {
            return reject(err);
          }
          ws = sftp.createWriteStream(path, options);
          ws.emit = (function(emit) {
            return function(key, val) {
              if (key === 'error') {
                if (val.code === 4) {
                  val = new Error("EISDIR: illegal operation on a directory, read");
                  val.errno = -21;
                  val.code = 'EISDIR';
                  val.syscall = 'read';
                } else if (val.code === 2) {
                  val = new Error(`ENOENT: no such file or directory, open '${path}'`);
                  val.code = 'ENOENT';
                  val.errno = -2;
                  val.syscall = 'open';
                  val.path = path;
                }
                return emit.call(this, 'error', val);
              }
              return emit.apply(this, arguments);
            };
          })(ws.emit);
          ws.on('close', function() {
            return sftp.end();
          });
          return resolve(ws);
        });
      });
    }
  },
  // # `ssh2-fs.exists(ssh, path)`

  // Command options are:   

  // *   `ssh`         SSH connection in case of a remote file path.  
  // *   `path`        Path to test.   

  // Returned value is:   

  // *   `exists`      True if the file exists.   

  // Test whether or not the given path exists by checking with the file system.
  exists: async function(ssh, path) {
    var err;
    if (!ssh) {
      try {
        await fs.promises.access(path, fs.constants.F_OK);
        return true;
      } catch (error1) {
        err = error1;
        return false;
      }
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; scsh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return reject(err);
          }
          return sftp.stat(path, function(err, attr) {
            sftp.end();
            if (err && (err.code !== 2 && err.type !== 'NO_SUCH_FILE')) {
              // ssh2@0.4.x use err.code; ssh2@0.3.x use err.type
              return reject(err);
            }
            return resolve(err ? false : true);
          });
        });
      });
    }
  },
  // # `ssh2-fs.futimes(ssh, path, atime, mtime)`

  // Sets the access time and modified time for the resource associated with handle. 
  futimes: function(ssh, path, atime, mtime) {
    if (!ssh) {
      return fs.promises.utimes(path, atime, mtime);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          var end;
          end = function(err) {
            sftp.end();
            if (!err) {
              return resolve();
            } else {
              return reject(err);
            }
          };
          if (err) {
            return end(err);
          }
          return sftp.open(path, 'r', function(err, fd) {
            if (err) {
              return end(err);
            }
            return sftp.futimes(fd, atime, mtime, function(err) {
              if (err) {
                return end(err);
              }
              return sftp.close(fd, function(err) {
                return end(err);
              });
            });
          });
        });
      });
    }
  },
  // # `ssh2-fs.lstat(ssh, path)`

  // The function returns the fs.Stats object. lstat() is identical to stat(), except
  // that if path is a symbolic link, then the link itself is stat-ed, not the file
  // that it refers to.
  lstat: function(ssh, path) {
    if (!ssh) {
      return fs.promises.lstat(path);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return reject(err);
          }
          return sftp.lstat(path, function(err, attr) {
            sftp.end();
            // see https://github.com/mscdex/ssh2-streams/blob/master/lib/sftp.js#L30
            // ssh2@0.4.x use err.code; ssh2@0.3.x use err.type
            if (err && (err.type === 'NO_SUCH_FILE' || err.code === 2)) {
              err.code = 'ENOENT';
              return reject(err);
            }
            return resolve(attr);
          });
        });
      });
    }
  },
  // # `ssh2-fs.mkdir(ssh, path, [options])`

  // Asynchronously creates a directory then resolves the Promise with either no
  // arguments, or the first folder path created if recursive is true. mode defaults to 0777.

  // In SSH, options is an [ATTR SSH2 object][attr] and may contains such attributes as
  // 'uid', 'gid' and 'mode'. If option is not an object, it is considered to be the
  // permission mode.

  // For the sake of compatibility, the local mode also accept additionnal options
  // than mode. Additionnal supported options are "uid' and "guid". It differs from
  // the native Node.js API which only accept a permission mode.

  // TODO: `recursive` is not implemented yet
  mkdir: async function(ssh, path, options = 0o0777) {
    if (typeof options !== 'object') {
      options = {
        mode: options
      };
    }
    if (typeof options.mode === 'string') {
      options.mode = parseInt(options.mode, 8);
    }
    if (!ssh) {
      await fs.promises.mkdir(path, options.mode);
      if (options.uid || options.gid) {
        return fs.promises.chown(path, options.uid, options.gid);
      }
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          var chown, finish, mkdir;
          if (err) {
            return reject(err);
          }
          mkdir = function() {
            return sftp.mkdir(path, options, function(err, attr) {
              if ((err != null ? err.message : void 0) === 'Failure') {
                err = new Error(`EEXIST: file already exists, mkdir '${path}'`);
                err.errno = 47;
                err.code = 'EEXIST';
                err.path = path;
              }
              if (err) {
                return finish(err);
              }
              return chown();
            });
          };
          chown = function() {
            if (!(options.uid || options.gid)) {
              return finish();
            }
            // chown should be required but mkdir doesnt seem to honor uid & gid attributes
            return sftp.chown(path, options.uid, options.gid, function(err) {
              if (err) {
                return finish(err);
              }
              return finish();
            });
          };
          finish = function(err) {
            sftp.end();
            if (!err) {
              return resolve();
            } else {
              return reject(err);
            }
          };
          return mkdir();
        });
      });
    }
  },
  // # `ssh2-fs.readdir(path)`

  // Reads the contents of a directory and return an array of the names of the files
  // in the directory excluding '.' and '..'.
  readdir: function(ssh, path) {
    if (!ssh) {
      return fs.promises.readdir(path);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          var not_a_dir;
          if (err) {
            return reject(err);
          }
          not_a_dir = function(err) {
            return sftp.stat(path, function(er, attr) {
              if (!er && !attr.isDirectory()) {
                err = Error(`ENOTDIR: not a directory, scandir '${path}'`);
                err.errno = 27;
                err.code = 'ENOTDIR';
                err.path = path;
              }
              return reject(err);
            });
          };
          return sftp.opendir(path, function(err, handle) {
            if (err) {
              return not_a_dir(err);
            }
            return sftp.readdir(handle, function(err1, files) {
              return sftp.close(handle, function(err2) {
                var file;
                if (err1 || err2) {
                  return reject(err1 || err2);
                }
                sftp.end();
                files = (function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = files.length; i < len; i++) {
                    file = files[i];
                    results.push(file.filename);
                  }
                  return results;
                })();
                return resolve(files);
              });
            });
          });
        });
      });
    }
  },
  // # `ssh2-fs.readFile(ssh, path, [options])` 

  // *   `filename` String   
  // *   `options` Object   
  // *   `options.encoding` String | Null default = null   
  // *   `options.flag` String default = 'r'

  // Asynchronously reads the entire contents of a file.
  readFile: function(ssh, path, options = {}) {
    if (typeof options === 'string') {
      options = {
        encoding: options
      };
    }
    if (!path) {
      throw Error(`Invalid path '${path}'`);
    }
    if (!ssh) {
      return fs.promises.readFile(path, options.encoding);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        if (options.autoClose == null) {
          options.autoClose = false; // Required after version 0.0.18 (sep 2015)
        }
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          var buffers, finish, s;
          if (err) {
            return reject(err);
          }
          s = sftp.createReadStream(path, options);
          buffers = [];
          s.on('data', function(buffer) {
            if (options.encoding) {
              buffer = Buffer.from(buffer, options.encoding);
            }
            return buffers.push(buffer);
          });
          s.on('error', function(err) {
            if (err.code === 4) {
              err = new Error("EISDIR: illegal operation on a directory, read");
              err.errno = -21;
              err.code = 'EISDIR';
              err.syscall = 'read';
            } else if (err.code === 2) {
              err = new Error(`ENOENT: no such file or directory, open '${path}'`);
              err.code = 'ENOENT';
              err.errno = -2;
              err.syscall = 'open';
              err.path = path;
            }
            return finish(err);
          });
          s.on('end', function() {
            return finish(null, Buffer.concat(buffers));
          });
          return finish = function(err, data) {
            if (!options.autoClose) {
              sftp.end();
            }
            if (!err && options.encoding) {
              data = data.toString();
            }
            if (!err) {
              return resolve(data);
            } else {
              return reject(err);
            }
          };
        });
      });
    }
  },
  // # `ssh2-fs.readlink(ssh, path)`

  // Return the link location.
  readlink: function(ssh, path) {
    if (!ssh) {
      return fs.promises.readlink(path);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return reject(err);
          }
          return sftp.readlink(path, function(err, target) {
            sftp.end();
            if (!err) {
              return resolve(target);
            } else {
              return reject(err);
            }
          });
        });
      });
    }
  },
  // # `ssh2-fs.rename(sshOrNull, oldPath, newPath)`

  // No promise arguments is given.
  rename: function(ssh, source, target) {
    if (!ssh) {
      return fs.promises.rename(source, target);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          return sftp.unlink(target, function() { // Required after version 0.0.18 (sep 2015)
            return sftp.rename(source, target, function(err) {
              sftp.end();
              if (!err) {
                return resolve(target);
              } else {
                return reject(err);
              }
            });
          });
        });
      });
    }
  },
  // # `ssh2-fs.rmdir(sshOrNull, path)`

  // No promise arguments is given.
  rmdir: function(ssh, target) {
    if (!ssh) {
      return fs.promises.rmdir(target);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          return sftp.rmdir(target, function(err) {
            sftp.end();
            if (err && (err.type === 'NO_SUCH_FILE' || err.code === 2)) {
              err.message = `ENOENT: no such file or directory, rmdir '${target}'`;
              err.errno = -2;
              err.code = 'ENOENT';
              err.syscall = 'rmdir';
              err.path = target;
            }
            if (!err) {
              return resolve();
            } else {
              return reject(err);
            }
          });
        });
      });
    }
  },
  // # `ssh2-fs.stat(ssh, path)`

  // The promise return an fs.Stats object. See the fs.Stats section below for more
  // information.
  stat: function(ssh, path) {
    // Not yet test, no way to know if file is a direct or a link
    if (!ssh) {
      // { dev: 16777218, mode: 16877, nlink: 19, uid: 501, gid: 20,
      // rdev: 0, blksize: 4096, ino: 1736226, size: 646, blocks: 0,
      // atime: Wed Feb 27 2013 23:25:07 GMT+0100 (CET), mtime: Tue Jan 29 2013 23:29:28 GMT+0100 (CET), ctime: Tue Jan 29 2013 23:29:28 GMT+0100 (CET) }
      return fs.promises.stat(path);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // { size: 646, uid: 501, gid: 20, permissions: 16877,
        // atime: 1362003965, mtime: 1359498568 }
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return reject(err);
          }
          return sftp.stat(path, function(err, attr) {
            sftp.end();
            // see https://github.com/mscdex/ssh2-streams/blob/master/lib/sftp.js#L30
            // ssh2@0.4.x use err.code; ssh2@0.3.x use err.type
            if (err && (err.type === 'NO_SUCH_FILE' || err.code === 2)) {
              err.code = 'ENOENT';
              return reject(err);
            }
            if (!err) {
              return resolve(attr);
            } else {
              return reject(err);
            }
          });
        });
      });
    }
  },
  // # `ssh2-fs.symlink(ssh, srcpath, linkPath)`

  // No promise argument is given. The type argument can be set to 'dir', 'file', or 'junction'
  // (default is 'file') and is only available on Windows (ignored on other
  // platforms). Note that Windows junction points require the target path to
  // be absolute. When using 'junction', the target argument will automatically
  // be normalized to absolute path. 
  symlink: function(ssh, srcpath, dstpath) {
    if (!ssh) {
      return fs.promises.symlink(srcpath, dstpath);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return reject(err);
          }
          return sftp.symlink(srcpath, dstpath, function(err) {
            sftp.end();
            if (!err) {
              return resolve();
            } else {
              return reject(err);
            }
          });
        });
      });
    }
  },
  // # `ssh2-fs.unlink(ssh, path)`

  // No promise argument is given.
  unlink: function(ssh, path) {
    if (!ssh) {
      return fs.unlink(path);
    } else {
      return new Promise(function(resolve, reject) {
        var open, ref, ref1;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return reject(err);
          }
          return sftp.unlink(path, function(err) {
            sftp.end();
            if (!err) {
              return resolve();
            } else {
              return reject(err);
            }
          });
        });
      });
    }
  },
  // # `ssh2-fs.writeFile(ssh, target, content, [options])`

  // *   `target` String   
  // *   `data` String | Buffer | stream reader   
  // *   `options` Object   
  // *   `options.encoding` String | Null default = 'utf8'   
  // *   `options.mode` Number default = 438 (aka 0666 in Octal)   
  // *   `options.flag` String default = 'w'     

  // Asynchronously writes data to a file, replacing the file if it already exists.
  // data can be a string or a buffer.

  // The encoding option is ignored if data is a buffer. It defaults to 'utf8'.
  writeFile: function(ssh, target, data, options = {}) {
    if (typeof options === 'string') {
      options = {
        encoding: options
      };
    }
    if (!ssh) {
      return new Promise(function(resolve, reject) {
        var chmod, chown, error, finish, write;
        error = false;
        write = function() {
          var stream;
          if (!(typeof data === 'string' || Buffer.isBuffer(data))) {
            data.on('error', function(err) {
              reject(err);
              return error = true;
            });
          }
          stream = fs.createWriteStream(target, options);
          if (typeof data === 'string' || Buffer.isBuffer(data)) {
            if (data) {
              stream.write(data);
            }
            stream.end();
          } else {
            data.pipe(stream);
          }
          stream.on('error', function(err) {
            if (!error) {
              return reject(err);
            }
          });
          stream.on('end', function() {
            return s.destroy();
          });
          return stream.on('close', function() {
            return chown();
          });
        };
        chown = function() {
          if (!((options.uid != null) || (options.gid != null))) {
            return chmod();
          }
          return fs.chown(target, options.uid, options.gid, function(err) {
            if (err) {
              return reject(err);
            }
            return chmod();
          });
        };
        chmod = function() {
          if (!options.mode) {
            return finish();
          }
          return fs.chmod(target, options.mode, function(err) {
            return finish(err);
          });
        };
        finish = function(err) {
          if (!error) {
            if (!err) {
              return resolve();
            } else {
              return reject(err);
            }
          }
        };
        return write();
      });
    } else {
      return new Promise(function(resolve, reject) {
        var error, open, ref, ref1;
        error = false;
        // ssh@0.4.x use "_sshstream" and "_sock"; ssh@0.3.x use "_state"
        open = ((ssh._state != null) && ssh._state !== 'closed') || (((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0));
        if (!open) {
          return reject(Error('Closed SSH Connection'));
        }
        if (!(typeof data === 'string' || Buffer.isBuffer(data))) {
          data.on('error', function(err) {
            reject(err);
            return error = true;
          });
        }
        return ssh.sftp(function(err, sftp) {
          var chmod, chown, finish, write;
          if (err) {
            if (!error) {
              reject(err);
            }
            error = true;
            return;
          }
          write = function() {
            var ws;
            ws = sftp.createWriteStream(target, options);
            if (typeof data === 'string' || Buffer.isBuffer(data)) {
              if (data) {
                ws.write(data);
              }
              ws.end();
            } else {
              data.pipe(ws);
            }
            ws.on('error', function(err) {
              return finish(err);
            });
            ws.on('end', function() {
              return ws.destroy();
            });
            return ws.on('close', function() {
              return chown();
            });
          };
          chown = function() {
            if (!((options.uid != null) || (options.gid != null))) {
              return chmod();
            }
            return sftp.chown(target, options.uid, options.gid, function(err) {
              if (err) {
                return finish(err);
              }
              return chmod();
            });
          };
          chmod = function() {
            if (!options.mode) {
              return finish();
            }
            return sftp.chmod(target, options.mode, function(err) {
              return finish(err);
            });
          };
          finish = function(err) {
            sftp.end();
            if (!error) {
              if (!err) {
                resolve();
              } else {
                reject(err);
              }
            }
            return error = true;
          };
          return write();
        });
      });
    }
  }
};

// [attr]: https://github.com/mscdex/ssh2-streams/blob/master/SFTPStream.md#attrs
