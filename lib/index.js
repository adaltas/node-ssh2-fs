// Generated by CoffeeScript 1.7.1
var fs;

fs = require('fs');

module.exports = {
  rename: function(ssh, source, destination, callback) {
    if (!ssh) {
      return fs.rename(source, destination, function(err) {
        return callback(err);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        return sftp.rename(source, destination, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  chown: function(ssh, path, uid, gid, callback) {
    if (!(uid || gid)) {
      return callback(new Error('Either option "uid" or "gid" is required'));
    }
    if (!ssh) {
      return fs.chown(path, uid, gid, function(err) {
        return callback(err);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.chown(path, uid, gid, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  chmod: function(ssh, path, mode, callback) {
    if (!ssh) {
      return fs.chmod(path, mode, function(err) {
        return callback(err);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.chmod(path, mode, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  stat: function(ssh, path, callback) {
    if (!ssh) {
      return fs.stat(path, function(err, stat) {
        return callback(err, stat);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.stat(path, function(err, attr) {
          sftp.end();
          if (err && err.type === 'NO_SUCH_FILE') {
            err.code = 'ENOENT';
            return callback(err);
          }
          return callback(err, attr);
        });
      });
    }
  },
  lstat: function(ssh, path, callback) {
    if (!ssh) {
      return fs.lstat(path, function(err, stat) {
        return callback(err, stat);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.lstat(path, function(err, attr) {
          sftp.end();
          if (err && err.type === 'NO_SUCH_FILE') {
            err.code = 'ENOENT';
            return callback(err);
          }
          return callback(err, attr);
        });
      });
    }
  },
  unlink: function(ssh, source, callback) {
    if (!ssh) {
      return fs.unlink(source, function(err) {
        return callback(err);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        return sftp.unlink(source, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  symlink: function(ssh, srcpath, dstpath, callback) {
    if (!ssh) {
      return fs.symlink(srcpath, dstpath, function(err) {
        return callback(err);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.symlink(srcpath, dstpath, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  readlink: function(ssh, path, callback) {
    if (!ssh) {
      return fs.readlink(path, function(err, target) {
        return callback(err, target);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.readlink(path, function(err, target) {
          sftp.end();
          return callback(err, target);
        });
      });
    }
  },
  unlink: function(ssh, path, callback) {
    if (!ssh) {
      return fs.unlink(path, function(err) {
        return callback(err);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.unlink(path, function(err) {
          sftp.end();
          return callback(err);
        });
      });
    }
  },
  mkdir: function(ssh, path, options, callback) {
    if (arguments.length === 3) {
      callback = options;
      options = 0x1ff;
    }
    if (typeof options !== 'object') {
      options = {
        mode: options
      };
    }
    if (options.permissions) {
      process.stderr.write('Deprecated, use mode instead of permissions');
      options.mode = options.permissions;
    }
    if (!ssh) {
      return fs.mkdir(path, options.mode, function(err) {
        return callback(err);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        var chmod, chown, finish, mkdir;
        if (err) {
          return callback(err);
        }
        mkdir = function() {
          return sftp.mkdir(path, options, function(err, attr) {
            if ((err != null ? err.message : void 0) === 'Failure') {
              err = new Error("EEXIST, mkdir '" + path + "'");
              err.errno = 47;
              err.code = 'EEXIST';
              err.path = path;
            }
            if (err) {
              return finish(err);
            }
            return chown();
          });
        };
        chown = function() {
          if (!(options.uid || options.gid)) {
            return chmod();
          }
          return sftp.chown(path, options.uid, options.gid, function(err) {
            if (err) {
              return finish(err);
            }
            return chmod();
          });
        };
        chmod = function() {
          if (!options.mode) {
            return finish();
          }
          return sftp.chmod(path, options.mode, function(err) {
            return finish(err);
          });
        };
        finish = function(err) {
          sftp.end();
          return callback(err);
        };
        return mkdir();
      });
    }
  },
  readdir: function(ssh, path, callback) {
    if (!ssh) {
      return fs.readdir(path, callback);
    } else {
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.opendir(path, function(err, handle) {
          if (err) {
            return callback(err);
          }
          return sftp.readdir(handle, function(err, files) {
            return sftp.close(handle, function(err) {
              var file;
              if (err) {
                return callback(err);
              }
              sftp.end();
              files = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = files.length; _i < _len; _i++) {
                  file = files[_i];
                  _results.push(file.filename);
                }
                return _results;
              })();
              return callback(err, files);
            });
          });
        });
      });
    }
  },
  readFile: function(ssh, path, options, callback) {
    if (arguments.length === 3) {
      callback = options;
      options = {};
    } else {
      if (typeof options === 'string') {
        options = {
          encoding: options
        };
      }
    }
    if (!path) {
      return callback(new Error("Invalid path '" + path + "'"));
    }
    if (!ssh) {
      return fs.readFile(path, options.encoding, function(err, content) {
        return callback(err, content);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        var data, finish, s;
        if (err) {
          return callback(err);
        }
        s = sftp.createReadStream(path, options);
        data = [];
        s.on('data', function(d) {
          return data.push(d.toString());
        });
        s.on('error', function(err) {
          err = new Error("ENOENT, open '" + path + "'");
          err.errno = 34;
          err.code = 'ENOENT';
          err.path = path;
          return finish(err);
        });
        s.on('close', function() {
          return finish(null, data.join(''));
        });
        return finish = function(err, data) {
          sftp.end();
          return callback(err, data);
        };
      });
    }
  },
  writeFile: function(ssh, source, content, options, callback) {
    var chmod, chown, finish, write;
    if (arguments.length === 4) {
      callback = options;
      options = {};
    } else {
      if (typeof options === 'string') {
        options = {
          encoding: options
        };
      }
    }
    if (!ssh) {
      write = function() {
        var stream;
        stream = fs.createWriteStream(source, options);
        if (typeof content === 'string' || buffer.Buffer.isBuffer(content)) {
          if (content) {
            stream.write(content);
          }
          stream.end();
        } else {
          content.pipe(stream);
        }
        stream.on('error', function(err) {
          return callback(err);
        });
        stream.on('end', function() {
          return s.destroy();
        });
        return stream.on('close', function() {
          return chown();
        });
      };
      chown = function() {
        if (!(options.uid || options.gid)) {
          return chmod();
        }
        return fs.chown(source, options.uid, options.gid, function(err) {
          if (err) {
            return callback(err);
          }
          return chmod();
        });
      };
      chmod = function() {
        if (!options.mode) {
          return finish();
        }
        return fs.chmod(source, options.mode, function(err) {
          return finish(err);
        });
      };
      finish = function(err) {
        return callback(err);
      };
      return write();
    } else {
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        write = function() {
          var s;
          s = sftp.createWriteStream(source, options);
          if (typeof content === 'string' || buffer.Buffer.isBuffer(content)) {
            if (content) {
              s.write(content);
            }
            s.end();
          } else {
            content.pipe(s);
          }
          s.on('error', function(err) {
            return finish(err);
          });
          s.on('end', function() {
            return s.destroy();
          });
          return s.on('close', function() {
            return chown();
          });
        };
        chown = function() {
          if (!(options.uid || options.gid)) {
            return chmod();
          }
          return sftp.chown(source, options.uid, options.gid, function(err) {
            if (err) {
              return finish(err);
            }
            return chmod();
          });
        };
        chmod = function() {
          if (!options.mode) {
            return finish();
          }
          return sftp.chmod(source, options.mode, function(err) {
            return finish(err);
          });
        };
        finish = function(err) {
          sftp.end();
          return callback(err);
        };
        return write();
      });
    }
  },
  exists: function(ssh, path, callback) {
    if (!ssh) {
      return fs.exists(path, function(exists) {
        return callback(null, exists);
      });
    } else {
      return ssh.sftp(function(err, sftp) {
        if (err) {
          return callback(err);
        }
        return sftp.stat(path, function(err, attr) {
          sftp.end();
          return callback(null, err ? false : true);
        });
      });
    }
  },
  createReadStream: function(ssh, source, options, callback) {
    if (arguments.length === 3) {
      callback = options;
      options = {};
    }
    if (!ssh) {
      return callback(null, fs.createReadStream(source, options));
    } else {
      return ssh.sftp(function(err, sftp) {
        var s;
        if (err) {
          return callback(err);
        }
        s = sftp.createReadStream(source, options);
        s.emit = (function(emit) {
          return function(key, val) {
            if (key === 'error' && val === void 0) {
              val = new Error("EISDIR, read");
              val.errno = 28;
              val.code = 'EISDIR';
              return emit.call(this, 'error', val);
            }
            if (key === 'error' && val.message === 'No such file') {
              val = new Error("ENOENT, open '" + source + "'");
              val.errno = 34;
              val.code = 'ENOENT';
              val.path = source;
              return emit.call(this, 'error', val);
            }
            return emit.apply(this, arguments);
          };
        })(s.emit);
        s.on('close', function() {
          return sftp.end();
        });
        return callback(null, s);
      });
    }
  },
  createWriteStream: function(ssh, path, options, callback) {
    if (arguments.length === 3) {
      callback = options;
      options = {};
    }
    if (!ssh) {
      return callback(null, fs.createWriteStream(path, options));
    } else {
      return ssh.sftp(function(err, sftp) {
        var ws;
        if (err) {
          return callback(err);
        }
        ws = sftp.createWriteStream(path, options);
        ws.on('close', function() {
          return sftp.end();
        });
        return callback(null, ws);
      });
    }
  }
};
